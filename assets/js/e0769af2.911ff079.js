"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[5349],{4154:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/motion-planning-overview","title":"Chapter 13: Motion Planning and Navigation","description":"Introduction","source":"@site/docs/physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/motion-planning-overview.md","sourceDirName":"physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation","slug":"/physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/motion-planning-overview","permalink":"/humanoid-robotics-book/docs/physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/motion-planning-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/A-Siddiqui-coder/humanoid-robotics-book/tree/main/docs-site/docs/physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/motion-planning-overview.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 13: Real-World Applications of Humanoid Robots","permalink":"/humanoid-robotics-book/docs/physical-ai-humanoid-robotics/part3-advanced-topics/chapter13-motion-planning-navigation/"},"next":{"title":"Chapter 14: Ethical Considerations and the Future of Physical AI","permalink":"/humanoid-robotics-book/docs/physical-ai-humanoid-robotics/part3-advanced-topics/chapter14-human-robot-interaction/"}}');var t=i(4848),a=i(8453);const s={sidebar_position:13},r="Chapter 13: Motion Planning and Navigation",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"13.1 The Navigation Stack",id:"131-the-navigation-stack",level:2},{value:"13.2 Global Path Planning",id:"132-global-path-planning",level:2},{value:"13.3 Local Path Planning and Collision Avoidance",id:"133-local-path-planning-and-collision-avoidance",level:2},{value:"13.4 Motion Planning for Manipulation",id:"134-motion-planning-for-manipulation",level:2},{value:"Sampling-Based Planners",id:"sampling-based-planners",level:3},{value:"13.5 Whole-Body Planning",id:"135-whole-body-planning",level:2}];function h(n){const e={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-13-motion-planning-and-navigation",children:"Chapter 13: Motion Planning and Navigation"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Navigation"})," is the science of getting from one place to another. For a robot, it's the process of answering three continuous questions:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:'"Where am I?"'})," (Localization)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:'"Where am I going?"'})," (The Goal)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:'"How do I get there?"'})," (Path Planning)"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Motion Planning"})," is the core of that third question. It is the process of computing a collision-free and dynamically feasible path from a start configuration to a goal configuration. This is a fundamental capability that ties together perception, mapping, control, and kinematics. Whether moving the entire robot through a room or just moving its arm to pick up an object, the robot must first plan a valid motion."]}),"\n",(0,t.jsx)(e.h2,{id:"131-the-navigation-stack",children:"13.1 The Navigation Stack"}),"\n",(0,t.jsx)(e.p,{children:'Robot navigation is typically structured as a layered system, often called a "navigation stack."'}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"The Map:"})," The foundation of navigation is a map of the environment, usually generated by a SLAM algorithm (Chapter 6). A common representation is a ",(0,t.jsx)(e.strong,{children:"costmap"}),', which is a 2D grid where each cell contains a value representing the "cost" of traversing that cell. Cells containing obstacles have an infinitely high cost, cells near obstacles have a high cost, and open space has a low cost.']}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"The Global Planner:"})," This component is responsible for finding a high-level path from the robot's current location to a distant goal. It operates on the overall map and finds an optimal path, like a GPS giving you driving directions across a city. It doesn't worry about dynamic obstacles or the robot's kinematics."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"The Local Planner:"})," This component is responsible for real-time collision avoidance. It takes the path from the global planner as a guide and computes the actual motor commands for the next few seconds. Its primary job is to generate dynamically feasible trajectories that avoid immediate obstacles (like a person walking in front of the robot), even if it means deviating temporarily from the global plan."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This layered approach allows the robot to make intelligent, long-range plans while remaining reactive to its immediate surroundings."}),"\n",(0,t.jsx)(e.h2,{id:"132-global-path-planning",children:"13.2 Global Path Planning"}),"\n",(0,t.jsx)(e.p,{children:'The goal of the global planner is to find the "best" path on the costmap. This is a classic graph search problem.'}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dijkstra's Algorithm:"})," A famous algorithm that is guaranteed to find the shortest path from a starting point to all other points on a graph. It works by exploring outwards, always expanding the path to the nearest unvisited node."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.em,{children:[(0,t.jsx)(e.em,{children:"A"})," (A-star):"]}),"* A* is the workhorse of global planning in robotics. It is an extension of Dijkstra's algorithm that is much more efficient. In addition to the actual cost to reach a node (like Dijkstra), A* uses a ",(0,t.jsx)(e.strong,{children:"heuristic"}),"\u2014an educated guess\u2014to estimate the cost from that node to the final goal. This allows it to prioritize its search in the general direction of the goal, avoiding the need to explore in all directions."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"133-local-path-planning-and-collision-avoidance",children:"13.3 Local Path Planning and Collision Avoidance"}),"\n",(0,t.jsxs)(e.p,{children:["The local planner's job is to turn the global plan into action. A widely used algorithm for this is the ",(0,t.jsx)(e.strong,{children:"Dynamic Window Approach (DWA)"}),". DWA works in a rapid, repetitive cycle:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sample Velocities:"}),' First, it creates a list of achievable linear and angular velocities that the robot can safely execute in the next short time step. This is the "dynamic window."']}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulate Trajectories:"})," For each pair of sampled velocities, it simulates the resulting curved trajectory for a short period into the future."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Score Trajectories:"})," Each simulated trajectory is evaluated and scored based on several criteria:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Obstacle Avoidance:"})," How close does it get to an obstacle? (High penalty for getting too close)."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Path Following:"})," How well does it follow the global path?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Goal Progress:"})," How much closer does it get to the local goal?"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Select and Execute:"})," The trajectory with the best score is chosen, and the corresponding linear and angular velocity commands are sent to the robot's motor controllers."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This entire cycle repeats many times per second, allowing the robot to move smoothly while reacting to changes in its environment."}),"\n",(0,t.jsx)(e.h2,{id:"134-motion-planning-for-manipulation",children:"13.4 Motion Planning for Manipulation"}),"\n",(0,t.jsx)(e.p,{children:"Planning for a multi-jointed arm is much more complex than planning for a mobile base. The challenge is the high dimensionality of the problem."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Configuration Space (C-Space):"})," Imagine a 7-DOF robot arm. Its ",(0,t.jsx)(e.strong,{children:"configuration"})," can be described by a list of its 7 joint angles. The space of all possible configurations is a 7-dimensional space called the C-Space. An obstacle in the 3D real world (workspace) corresponds to a complex, high-dimensional obstacle region in C-Space. The motion planning problem is now transformed into finding a path for a single point from a start configuration to a goal configuration, while avoiding the C-Space obstacles."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"sampling-based-planners",children:"Sampling-Based Planners"}),"\n",(0,t.jsx)(e.p,{children:"Because C-Space is too complex to represent explicitly, modern planners use sampling-based techniques."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rapidly-exploring Random Tree (RRT):"}),' This is one of the most popular and effective algorithms for high-dimensional motion planning. RRT works by "growing" a tree of valid, collision-free configurations. It starts the tree at the arm\'s initial configuration. Then, it repeatedly samples a random configuration in the C-Space and tries to expand the nearest node in the tree towards that random sample. This causes the tree to rapidly explore the reachable space. When a path from the start to the goal is found, the plan is complete. Variants like ',(0,t.jsx)(e.strong,{children:"RRT"}),"* continue to search for better and shorter paths after the first one is found."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"135-whole-body-planning",children:"13.5 Whole-Body Planning"}),"\n",(0,t.jsxs)(e.p,{children:["For a humanoid, we cannot plan for the arms and legs in isolation. Reaching for an object with an arm changes the robot's Center of Mass, which must be compensated for by the legs and torso to maintain balance. This requires ",(0,t.jsx)(e.strong,{children:"Whole-Body Motion Planning"}),"."]}),"\n",(0,t.jsx)(e.p,{children:"This is the ultimate motion planning challenge, where the planner must find a single, dynamically stable, and collision-free trajectory for all 30+ joints of the robot simultaneously. It needs to decide not only where the arm should move, but also how the legs, torso, and head should move to support the action, maintain balance, and avoid collisions. This is an active area of advanced research that combines sampling-based planning with trajectory optimization and contact mechanics to generate the fluid, graceful, and purposeful movements that will allow humanoids to operate effectively in complex environments."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var o=i(6540);const t={},a=o.createContext(t);function s(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);